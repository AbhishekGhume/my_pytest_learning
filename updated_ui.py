import customtkinter as ctk
import subprocess
import threading
import os
import sys
import queue
from typing import Optional

# --- Gherkin Feature File Template ---
FEATURE_TEMPLATE = """@cycle_start @maverick

Feature: Maverick Washer Bench Tests (Generated by GUI)

  Scenario Outline: Run a Washer Cycle from the HMI
    Given the NTL Hub is started
    And system is in programming state
    And the washer lid is closed and locked
    Then the user selects the "<Cycle>"
    Then the user changes the temperature to "<Temp>" and soil level to "<Soil>"
    And the user makes the payment of $<Amount> in coins
    And the user press the start button
    Then user checks the door is locked
    Then the cold valve state is ON
    And the water fill is simulated using a pump
    Then check pressure sensor is activated
    Then the user cancels the cycle

    Examples:
      | Cycle        | Temp   | Soil    | Amount |
      | {cycle}      | {temp} | {soil}  | {amount} |
"""

class TestRunnerApp(ctk.CTk):
    def __init__(self):
        super().__init__()

        self.title("Maverick Automation Runner")
        self.geometry("1200x750")
        ctk.set_appearance_mode("Dark")
        ctk.set_default_color_theme("blue")
        
        # --- Define colors for button states ---
        self.SELECTED_COLOR = ctk.ThemeManager.theme["CTkButton"]["fg_color"]
        self.DESELECTED_COLOR = "transparent"

        # --- Thread-safe queue for output ---
        self.output_queue = queue.Queue()
        self.guardian_process: Optional[subprocess.Popen] = None
        self.pytest_process: Optional[subprocess.Popen] = None
        
        # --- Configure Grid Layout ---
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(5, weight=1)

        # --- Title ---
        self.title_label = ctk.CTkLabel(self, text="Maverick Automation", font=ctk.CTkFont(size=20, weight="bold"))
        self.title_label.grid(row=0, column=0, padx=20, pady=(20, 10))

        # --- State Variables ---
        self.appliance_var = ctk.StringVar(value="VA Washer")
        self.cycle_var = ctk.StringVar(value="Delicate")
        self.temp_var = ctk.StringVar(value="Cold")
        self.soil_var = ctk.StringVar(value="Light")
        self.payment_var = ctk.StringVar(value="$1.00")
        
        # --- Appliance Selection Frame ---
        appliance_frame = ctk.CTkFrame(self, fg_color="transparent")
        appliance_frame.grid(row=1, column=0, padx=20, pady=10)

        self.appliance_buttons = {
            "VA Washer": ctk.CTkButton(appliance_frame, text="VA Washer", width=140, command=lambda: self.select_appliance("VA Washer")),
            "Dryer": ctk.CTkButton(appliance_frame, text="Dryer", width=140, command=lambda: self.select_appliance("Dryer"))
        }
        self.appliance_buttons["VA Washer"].grid(row=0, column=0, padx=5, pady=5)
        self.appliance_buttons["Dryer"].grid(row=0, column=1, padx=5, pady=5)
        
        # --- Cycle Selection Frame ---
        cycle_frame = ctk.CTkFrame(self, fg_color="transparent")
        cycle_frame.grid(row=2, column=0, padx=20, pady=10)
        
        self.cycle_buttons = {
            "Delicate": ctk.CTkButton(cycle_frame, text="Delicate", width=140, command=lambda: self.select_cycle("Delicate")),
            "Normal": ctk.CTkButton(cycle_frame, text="Normal", width=140, command=lambda: self.select_cycle("Normal")),
            "Heavy Duty": ctk.CTkButton(cycle_frame, text="Heavy Duty", width=140, command=lambda: self.select_cycle("Heavy Duty"))
        }
        self.cycle_buttons["Delicate"].grid(row=0, column=0, padx=5, pady=5)
        self.cycle_buttons["Normal"].grid(row=0, column=1, padx=5, pady=5)
        self.cycle_buttons["Heavy Duty"].grid(row=0, column=2, padx=5, pady=5)

        # --- Modifiers Frame (for Temp and Soil) ---
        self.modifiers_frame = ctk.CTkFrame(self, fg_color="transparent")
        self.modifiers_frame.grid(row=3, column=0, padx=20, pady=10)
        
        # Temperature Group
        temp_group = ctk.CTkFrame(self.modifiers_frame)
        temp_group.grid(row=0, column=0, padx=10, pady=5)
        ctk.CTkLabel(temp_group, text="Temperature").pack(pady=(5,0))
        temp_button_frame = ctk.CTkFrame(temp_group, fg_color="transparent")
        temp_button_frame.pack(pady=5, padx=5)

        self.temp_buttons = {
            "Cold": ctk.CTkButton(temp_button_frame, text="Cold", command=lambda: self.select_temp("Cold")),
            "Warm": ctk.CTkButton(temp_button_frame, text="Warm", command=lambda: self.select_temp("Warm")),
            "Hot": ctk.CTkButton(temp_button_frame, text="Hot", command=lambda: self.select_temp("Hot"))
        }
        self.temp_buttons["Cold"].grid(row=0, column=0, padx=5)
        self.temp_buttons["Warm"].grid(row=0, column=1, padx=5)
        self.temp_buttons["Hot"].grid(row=0, column=2, padx=5)

        # Soil Level Group
        soil_group = ctk.CTkFrame(self.modifiers_frame)
        soil_group.grid(row=0, column=1, padx=10, pady=5)
        ctk.CTkLabel(soil_group, text="Soil Level").pack(pady=(5,0))
        soil_button_frame = ctk.CTkFrame(soil_group, fg_color="transparent")
        soil_button_frame.pack(pady=5, padx=5)

        self.soil_buttons = {
            "Light": ctk.CTkButton(soil_button_frame, text="Light", command=lambda: self.select_soil("Light")),
            "Normal": ctk.CTkButton(soil_button_frame, text="Normal", command=lambda: self.select_soil("Normal")),
            "Heavy": ctk.CTkButton(soil_button_frame, text="Heavy", command=lambda: self.select_soil("Heavy"))
        }
        self.soil_buttons["Light"].grid(row=0, column=0, padx=5)
        self.soil_buttons["Normal"].grid(row=0, column=1, padx=5)
        self.soil_buttons["Heavy"].grid(row=0, column=2, padx=5)

        # --- Controls Frame (Payment and Start Button) ---
        controls_frame = ctk.CTkFrame(self)
        controls_frame.grid(row=4, column=0, padx=20, pady=10, sticky="ew")
        controls_frame.grid_columnconfigure(0, weight=1)
        controls_frame.grid_columnconfigure(1, weight=1)

        # Payment Display
        payment_frame = ctk.CTkFrame(controls_frame, fg_color="transparent")
        payment_frame.grid(row=0, column=0, sticky="e", padx=10)
        self.payment_label = ctk.CTkLabel(payment_frame, text="Payment ($):")
        self.payment_label.pack(side="left", padx=(0,5))
        self.payment_display = ctk.CTkEntry(payment_frame, textvariable=self.payment_var, state="disabled", width=100)
        self.payment_display.pack(side="left")

        # Start Button
        self.start_button = ctk.CTkButton(controls_frame, text="Start Test", command=self.start_test)
        self.start_button.grid(row=0, column=1, padx=10, pady=10, sticky="w")
        
        # --- Output Log ---
        self.output_textbox = ctk.CTkTextbox(self, font=("Courier New", 12))
        self.output_textbox.grid(row=5, column=0, padx=20, pady=(10, 20), sticky="nsew")

        # --- Initialize default button states ---
        self.select_appliance(self.appliance_var.get())
        self.select_cycle(self.cycle_var.get())
        self.select_temp(self.temp_var.get())
        self.select_soil(self.soil_var.get())
        
        # Start queue processing
        self.process_output_queue()
        
    def select_appliance(self, choice: str):
        """Handler for appliance button clicks. Disables/enables modifier options."""
        self.appliance_var.set(choice)
        for name, button in self.appliance_buttons.items():
            button.configure(fg_color=self.SELECTED_COLOR if name == choice else self.DESELECTED_COLOR)

        # Enable or disable modifier buttons based on appliance type
        new_state = "normal" if choice == "VA Washer" else "disabled"
        for button in self.temp_buttons.values():
            button.configure(state=new_state)
        for button in self.soil_buttons.values():
            button.configure(state=new_state)

    def select_cycle(self, choice: str):
        """Handler for cycle button clicks."""
        self.cycle_var.set(choice)
        self.update_payment(choice)
        for name, button in self.cycle_buttons.items():
            button.configure(fg_color=self.SELECTED_COLOR if name == choice else self.DESELECTED_COLOR)

    def select_temp(self, choice: str):
        """Handler for temperature button clicks."""
        self.temp_var.set(choice)
        for name, button in self.temp_buttons.items():
            button.configure(fg_color=self.SELECTED_COLOR if name == choice else self.DESELECTED_COLOR)
            
    def select_soil(self, choice: str):
        """Handler for soil level button clicks."""
        self.soil_var.set(choice)
        for name, button in self.soil_buttons.items():
            button.configure(fg_color=self.SELECTED_COLOR if name == choice else self.DESELECTED_COLOR)
    
    def update_payment(self, selected_cycle: str):
        """Updates the payment amount based on the selected cycle."""
        prices = {
            "Delicate": "$1.00",
            "Normal": "$2.00",
            "Heavy Duty": "$3.50"
        }
        new_price = prices.get(selected_cycle, "$0.00")
        self.payment_var.set(new_price)

    def start_test(self):
        """Gathers data, writes the feature file, and starts the test in a new thread."""
        self.start_button.configure(state="disabled", text="Running...")
        self.output_textbox.delete("1.0", "end")
        
        payment_value = self.payment_var.get().replace("$", "")
        
        # For a dryer test, we can pass empty strings for temp and soil
        temp_value = self.temp_var.get() if self.appliance_var.get() == "VA Washer" else ""
        soil_value = self.soil_var.get() if self.appliance_var.get() == "VA Washer" else ""

        choices = {
            "cycle": self.cycle_var.get(),
            "temp": temp_value,
            "soil": soil_value,
            "amount": payment_value
        }

        feature_content = FEATURE_TEMPLATE.format(**choices)
        self.temp_feature_file = "temp_test.feature"

        script_dir = os.path.dirname(os.path.abspath(__file__))
        features_dir = os.path.join(script_dir, 'features')
        os.makedirs(features_dir, exist_ok=True)
        self.temp_feature_file_path = os.path.join(features_dir, self.temp_feature_file)

        with open(self.temp_feature_file_path, "w", encoding='utf-8') as f:
            f.write(feature_content)
        
        test_thread = threading.Thread(target=self.run_pytest_in_thread, daemon=True)
        test_thread.start()
    
    def process_output_queue(self):
        """Process messages from the queue and update the UI (runs in main thread)."""
        try:
            while True:
                message = self.output_queue.get_nowait()
                if message == "TEST_COMPLETE":
                    self.on_test_complete()
                else:
                    self.output_textbox.insert("end", message)
                    self.output_textbox.see("end")
        except queue.Empty:
            pass
        finally:
            # Schedule next check
            self.after(100, self.process_output_queue)
        
    def run_pytest_in_thread(self):
        """
        Starts guardian.py in the background, then executes the pytest command.
        Ensures the guardian process is terminated after the test finishes.
        """
        script_dir = os.path.dirname(os.path.abspath(__file__))

        try:
            # Uncomment to enable guardian script
            # self.output_queue.put("Starting guardian script...\n")
            # guardian_command = ["python", "-u", "guardian.py"]
            # self.guardian_process = subprocess.Popen(
            #     guardian_command,
            #     stdout=subprocess.PIPE,
            #     stderr=subprocess.STDOUT,
            #     text=True,
            #     encoding='utf-8',
            #     cwd=script_dir
            # )
            # self.output_queue.put("Guardian script started.\n\n")

            # Define and run the pytest command
            pytest_command = [
                sys.executable,
                "-m", "pytest", "-rA",
                "--cache-clear",
                "-m", "maverick and cycle_start"
            ]
            
            self.pytest_process = subprocess.Popen(
                pytest_command,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                encoding='utf-8',
                bufsize=1,
                cwd=script_dir
            )
            
            # Stream pytest output to the queue
            for line in iter(self.pytest_process.stdout.readline, ''):
                if line:
                    self.output_queue.put(line)
            
            self.pytest_process.stdout.close()
            self.pytest_process.wait()

        except Exception as e:
            self.output_queue.put(f"\nError running test: {str(e)}\n")
        finally:
            # Stop the guardian script after tests are done
            if self.guardian_process:
                try:
                    self.output_queue.put("\nTerminating guardian script...\n")
                    self.guardian_process.terminate()
                    self.guardian_process.wait(timeout=5)
                    self.output_queue.put("Guardian script terminated.\n")
                except Exception as e:
                    self.output_queue.put(f"Error terminating guardian: {str(e)}\n")
                    if self.guardian_process:
                        self.guardian_process.kill()  # Force kill if terminate fails

        # Signal completion
        self.output_queue.put("TEST_COMPLETE")

    def on_test_complete(self):
        """Called when the test is finished."""
        self.start_button.configure(state="normal", text="Start Test")
        self.output_textbox.insert("end", "\n--- TEST COMPLETE ---\n")
        self.output_textbox.see("end")
        
    def destroy(self):
        """Clean up processes when closing the application."""
        if self.pytest_process:
            try:
                self.pytest_process.terminate()
                self.pytest_process.wait(timeout=2)
            except:
                self.pytest_process.kill()
                
        if self.guardian_process:
            try:
                self.guardian_process.terminate()
                self.guardian_process.wait(timeout=2)
            except:
                self.guardian_process.kill()
                
        super().destroy()

if __name__ == "__main__":
    app = TestRunnerApp()
    app.mainloop()